import {
  Injectable,
  NotFoundException,
  BadRequestException,
  ConflictException,
} from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import {
  CreateSalesOrderDto,
  OrderStatus,
  PaymentStatus,
  DiscountType,
} from './dto/create-sales-order.dto';
import { UpdateSalesOrderDto } from './dto/update-sales-order.dto';
import { SalesOrderQueryDto } from './dto/sales-order-query.dto';
import { CreatePaymentDto } from './dto/create-payment.dto';
import { Prisma } from '@prisma/client';

@Injectable()
export class SalesService {
  constructor(private prisma: PrismaService) {}

  async create(createSalesOrderDto: CreateSalesOrderDto) {
    try {
      const { items, ...orderData } = createSalesOrderDto;

      // Calculate totals if not provided
      let subtotal = orderData.subtotal || 0;
      let discountAmount = orderData.discount_amount || 0;
      let taxAmount = orderData.tax_amount || 0;

      if (!orderData.subtotal) {
        subtotal = items.reduce(
          (sum, item) => sum + item.unit_price * item.quantity,
          0,
        );
        taxAmount = items.reduce(
          (sum, item) => sum + (item.tax_amount || 0) * item.quantity,
          0,
        );
      }

      // Calculate discount based on type
      const discountType = orderData.discount_type || DiscountType.FIXED;
      const discountPercent = orderData.discount_percent || 0;

      if (discountType === DiscountType.PERCENT && discountPercent > 0) {
        discountAmount = (subtotal * discountPercent) / 100;
      } else if (!orderData.discount_amount) {
        discountAmount = items.reduce(
          (sum, item) => sum + (item.discount_amount || 0) * item.quantity,
          0,
        );
      }

      // Validate discount doesn't exceed subtotal
      if (discountAmount > subtotal) {
        throw new BadRequestException('Discount amount cannot exceed subtotal');
      }

      const totalAmount =
        orderData.total_amount ||
        subtotal - discountAmount + taxAmount + (orderData.shipping_cost || 0);

      // Prepare order data (order_number will be auto-generated by database)
      const data: Prisma.sales_ordersCreateInput = {
        order_number: '', // Will be auto-generated by database trigger
        customer_name: orderData.customer_name,
        customer_phone: orderData.customer_phone,
        customer_email: orderData.customer_email,
        channel: orderData.channel,
        status: orderData.status || OrderStatus.DRAFT,
        payment_status: orderData.payment_status || PaymentStatus.UNPAID,
        subtotal: new Prisma.Decimal(subtotal),
        discount_type: discountType,
        discount_percent: discountPercent
          ? new Prisma.Decimal(discountPercent)
          : undefined,
        discount_amount: new Prisma.Decimal(discountAmount),
        tax_amount: new Prisma.Decimal(taxAmount),
        shipping_cost: orderData.shipping_cost
          ? new Prisma.Decimal(orderData.shipping_cost)
          : undefined,
        total_amount: new Prisma.Decimal(totalAmount),
        shipping_address: orderData.shipping_address,
        shipping_city: orderData.shipping_city,
        notes: orderData.notes,
        stores: orderData.store_id
          ? {
              connect: { id: orderData.store_id },
            }
          : undefined,
      };

      if (orderData.customer_id) {
        data.customers = { connect: { id: orderData.customer_id } };
      }

      if (orderData.created_by) {
        data.user_profiles_sales_orders_created_byTouser_profiles = {
          connect: { id: orderData.created_by },
        };
      }

      // Create order with items in a transaction
      const order = await this.prisma.$transaction(async (tx) => {
        // Create the order (order_number will be auto-generated by database function)
        const newOrder = await tx.sales_orders.create({
          data,
          include: {
            customers: true,
            stores: true,
            user_profiles_sales_orders_created_byTouser_profiles: true,
          },
        });

        // Get warehouse ID from store for inventory transactions
        const warehouseId = newOrder.stores?.default_warehouse_id;

        // Create order items
        const orderItems = await Promise.all(
          items.map((item) => {
            const totalPrice =
              (item.unit_price -
                (item.discount_amount || 0) +
                (item.tax_amount || 0)) *
              item.quantity;

            const itemData: Prisma.sales_order_itemsCreateInput = {
              product_name: '', // Will be filled from product
              quantity: item.quantity,
              unit_price: new Prisma.Decimal(item.unit_price),
              discount_amount: item.discount_amount
                ? new Prisma.Decimal(item.discount_amount)
                : undefined,
              tax_amount: item.tax_amount
                ? new Prisma.Decimal(item.tax_amount)
                : undefined,
              total_amount: new Prisma.Decimal(totalPrice),
              notes: item.notes,
              sales_orders: { connect: { id: newOrder.id } },
              products: { connect: { id: item.product_id } },
            };

            if (item.product_variant_id) {
              itemData.product_variants = {
                connect: { id: item.product_variant_id },
              };
            }

            return tx.sales_order_items.create({
              data: itemData,
              include: {
                products: true,
                product_variants: true,
              },
            });
          }),
        );

        // Create inventory transactions for each item (SALE type) using store's default warehouse
        if (warehouseId) {
          const stockLocationId = warehouseId;
          await Promise.all(
            items.map((item) => {
              const transactionData: Prisma.inventory_transactionsCreateInput =
                {
                  transaction_type: 'SALE',
                  quantity: -Math.abs(item.quantity),
                  reference_id: newOrder.id,
                  reference_type: 'sales_order',
                  stock_locations: { connect: { id: stockLocationId } },
                  products: { connect: { id: item.product_id } },
                };

              if (item.product_variant_id) {
                transactionData.product_variants = {
                  connect: { id: item.product_variant_id },
                };
              }

              if (orderData.created_by) {
                transactionData.user_profiles = {
                  connect: { id: orderData.created_by },
                };
              }

              return tx.inventory_transactions.create({
                data: transactionData,
              });
            }),
          );
        }

        return { ...newOrder, sales_order_items: orderItems };
      });

      return order;
    } catch (error) {
      throw new BadRequestException(
        `Failed to create sales order: ${error.message}`,
      );
    }
  }

  async findAll(query: SalesOrderQueryDto) {
    const {
      page = 1,
      limit = 20,
      search,
      sort_by = 'created_at',
      sort_order = 'desc',
      from_date,
      to_date,
      ...filters
    } = query;
    const skip = (page - 1) * limit;

    const where: Prisma.sales_ordersWhereInput = {};

    if (search) {
      where.OR = [
        { order_number: { contains: search, mode: 'insensitive' } },
        { customer_name: { contains: search, mode: 'insensitive' } },
        { customer_phone: { contains: search, mode: 'insensitive' } },
      ];
    }

    if (filters.customer_id) where.customer_id = filters.customer_id;
    if (filters.store_id) where.store_id = filters.store_id;
    if (filters.created_by) where.created_by = filters.created_by;
    if (filters.processed_by) where.processed_by = filters.processed_by;
    if (filters.status) where.status = filters.status;
    if (filters.payment_status) where.payment_status = filters.payment_status;
    if (filters.channel) where.channel = filters.channel;

    if (from_date || to_date) {
      where.created_at = {};
      if (from_date) where.created_at.gte = new Date(from_date);
      if (to_date) where.created_at.lte = new Date(to_date);
    }

    const [orders, total] = await Promise.all([
      this.prisma.sales_orders.findMany({
        where,
        skip,
        take: limit,
        orderBy: { [sort_by]: sort_order },
        include: {
          customers: true,
          stores: true,
          user_profiles_sales_orders_created_byTouser_profiles: true,
          user_profiles_sales_orders_processed_byTouser_profiles: true,
          sales_order_items: {
            include: {
              products: true,
              product_variants: true,
            },
          },
          sales_order_payments: true,
        },
      }),
      this.prisma.sales_orders.count({ where }),
    ]);

    return {
      data: orders,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  async findOne(id: string) {
    const order = await this.prisma.sales_orders.findUnique({
      where: { id },
      include: {
        customers: true,
        stores: true,
        user_profiles_sales_orders_created_byTouser_profiles: true,
        user_profiles_sales_orders_processed_byTouser_profiles: true,
        sales_order_items: {
          include: {
            products: true,
            product_variants: true,
          },
        },
        sales_order_payments: {
          include: {
            user_profiles: true,
          },
        },
      },
    });

    if (!order) {
      throw new NotFoundException(`Sales order with ID "${id}" not found`);
    }

    return order;
  }

  async update(id: string, updateSalesOrderDto: UpdateSalesOrderDto) {
    try {
      await this.findOne(id);

      const data: Prisma.sales_ordersUpdateInput = {
        ...updateSalesOrderDto,
        subtotal: updateSalesOrderDto.subtotal
          ? new Prisma.Decimal(updateSalesOrderDto.subtotal)
          : undefined,
        discount_amount: updateSalesOrderDto.discount_amount
          ? new Prisma.Decimal(updateSalesOrderDto.discount_amount)
          : undefined,
        tax_amount: updateSalesOrderDto.tax_amount
          ? new Prisma.Decimal(updateSalesOrderDto.tax_amount)
          : undefined,
        shipping_cost: updateSalesOrderDto.shipping_cost
          ? new Prisma.Decimal(updateSalesOrderDto.shipping_cost)
          : undefined,
        total_amount: updateSalesOrderDto.total_amount
          ? new Prisma.Decimal(updateSalesOrderDto.total_amount)
          : undefined,
      };

      if (updateSalesOrderDto.customer_id) {
        data.customers = { connect: { id: updateSalesOrderDto.customer_id } };
      }

      // Store update is handled via store_id field directly

      if (updateSalesOrderDto.created_by) {
        data.user_profiles_sales_orders_created_byTouser_profiles = {
          connect: { id: updateSalesOrderDto.created_by },
        };
      }

      const updatedOrder = await this.prisma.sales_orders.update({
        where: { id },
        data,
        include: {
          customers: true,
          stores: true,
          user_profiles_sales_orders_created_byTouser_profiles: true,
          user_profiles_sales_orders_processed_byTouser_profiles: true,
          sales_order_items: {
            include: {
              products: true,
              product_variants: true,
            },
          },
          sales_order_payments: true,
        },
      });

      return updatedOrder;
    } catch (error) {
      throw new BadRequestException(
        `Failed to update sales order: ${error.message}`,
      );
    }
  }

  async cancel(id: string) {
    try {
      const order = await this.findOne(id);

      if (order.status === OrderStatus.CANCELLED) {
        throw new ConflictException('Order is already cancelled');
      }

      if (order.status === OrderStatus.COMPLETED) {
        throw new ConflictException('Cannot cancel a completed order');
      }

      // Get warehouse ID from store for inventory transactions
      const warehouseId = order.stores?.default_warehouse_id;

      // Cancel the order and create RETURN inventory transactions
      const cancelledOrder = await this.prisma.$transaction(async (tx) => {
        // Update order status
        const updated = await tx.sales_orders.update({
          where: { id },
          data: {
            status: OrderStatus.CANCELLED,
          },
          include: {
            sales_order_items: {
              include: {
                products: true,
                product_variants: true,
              },
            },
          },
        });

        // Create RETURN transactions for inventory items using store's warehouse
        if (warehouseId) {
          for (const item of updated.sales_order_items) {
            await tx.inventory_transactions.create({
              data: {
                transaction_type: 'RETURN',
                quantity: Math.abs(item.quantity),
                reference_id: order.id,
                reference_type: 'sales_order_cancellation',
                stock_locations: { connect: { id: warehouseId } },
                products: { connect: { id: item.product_id! } },
                product_variants: item.product_variant_id
                  ? { connect: { id: item.product_variant_id } }
                  : undefined,
              },
            });
          }
        }

        return updated;
      });

      return cancelledOrder;
    } catch (error) {
      throw new BadRequestException(
        `Failed to cancel sales order: ${error.message}`,
      );
    }
  }

  async addPayment(createPaymentDto: CreatePaymentDto) {
    try {
      const order = await this.findOne(createPaymentDto.sales_order_id);

      // Calculate total paid after this payment
      const totalPaid = order.sales_order_payments.reduce(
        (sum, payment) => sum + Number(payment.amount),
        0,
      );

      const totalAmount = Number(order.total_amount);
      const newPaidAmount = totalPaid + createPaymentDto.amount;

      if (newPaidAmount > totalAmount) {
        throw new BadRequestException('Payment amount exceeds order total');
      }

      // Create payment
      const payment = await this.prisma.sales_order_payments.create({
        data: {
          sales_orders: { connect: { id: createPaymentDto.sales_order_id } },
          payment_method: createPaymentDto.payment_method,
          amount: new Prisma.Decimal(createPaymentDto.amount),
          transaction_id: createPaymentDto.transaction_id,
          authorization_code: createPaymentDto.authorization_code,
          amount_tendered: createPaymentDto.amount_tendered
            ? new Prisma.Decimal(createPaymentDto.amount_tendered)
            : undefined,
          change_given: createPaymentDto.change_given
            ? new Prisma.Decimal(createPaymentDto.change_given)
            : undefined,
          notes: createPaymentDto.notes,
          user_profiles: createPaymentDto.received_by
            ? { connect: { id: createPaymentDto.received_by } }
            : undefined,
        },
        include: {
          sales_orders: true,
          user_profiles: true,
        },
      });

      // Update order payment status
      let paymentStatus = PaymentStatus.PARTIAL;
      if (newPaidAmount >= totalAmount) {
        paymentStatus = PaymentStatus.PAID;
      } else if (newPaidAmount === 0) {
        paymentStatus = PaymentStatus.UNPAID;
      }

      await this.prisma.sales_orders.update({
        where: { id: createPaymentDto.sales_order_id },
        data: {
          payment_status: paymentStatus,
          payment_date:
            paymentStatus === PaymentStatus.PAID ? new Date() : null,
        },
      });

      return payment;
    } catch (error) {
      throw new BadRequestException(`Failed to add payment: ${error.message}`);
    }
  }

  // Status transition validation
  private validateStatusTransition(
    currentStatus: string,
    newStatus: string,
  ): boolean {
    const validTransitions: Record<string, string[]> = {
      [OrderStatus.DRAFT]: [OrderStatus.CONFIRMED, OrderStatus.CANCELLED],
      [OrderStatus.CONFIRMED]: [OrderStatus.PROCESSING, OrderStatus.CANCELLED],
      [OrderStatus.PROCESSING]: [OrderStatus.READY, OrderStatus.CANCELLED],
      [OrderStatus.READY]: [OrderStatus.COMPLETED, OrderStatus.CANCELLED],
      [OrderStatus.COMPLETED]: [], // Terminal state - no transitions allowed
      [OrderStatus.CANCELLED]: [], // Terminal state - no transitions allowed
    };

    return validTransitions[currentStatus]?.includes(newStatus) || false;
  }

  async confirm(id: string, userId?: string) {
    try {
      const order = await this.findOne(id);

      if (order.status !== OrderStatus.DRAFT) {
        throw new ConflictException('Only draft orders can be confirmed');
      }

      // Get warehouse ID from store for inventory transactions
      const warehouseId = order.stores?.default_warehouse_id;

      // Confirm the order and create inventory transactions
      const confirmedOrder = await this.prisma.$transaction(async (tx) => {
        // Update order status
        const updated = await tx.sales_orders.update({
          where: { id },
          data: {
            status: OrderStatus.CONFIRMED,
            processed_by: userId,
          },
          include: {
            sales_order_items: {
              include: {
                products: true,
                product_variants: true,
              },
            },
            customers: true,
          },
        });

        // Create inventory SALE transactions for each item using store's warehouse
        if (warehouseId) {
          for (const item of updated.sales_order_items) {
            await tx.inventory_transactions.create({
              data: {
                transaction_type: 'SALE',
                quantity: -Math.abs(item.quantity),
                reference_id: order.id,
                reference_type: 'sales_order',
                stock_locations: { connect: { id: warehouseId } },
                products: { connect: { id: item.product_id! } },
                product_variants: item.product_variant_id
                  ? { connect: { id: item.product_variant_id } }
                  : undefined,
                user_profiles: userId ? { connect: { id: userId } } : undefined,
              },
            });
          }
        }

        // Create customer receivable if customer exists
        if (order.customer_id) {
          await tx.customer_receivables.create({
            data: {
              customer_id: order.customer_id,
              sales_order_id: order.id,
              original_amount: order.total_amount,
              paid_amount: new Prisma.Decimal(0),
              balance: order.total_amount,
              status: 'unpaid',
            },
          });
        }

        return updated;
      });

      return confirmedOrder;
    } catch (error) {
      if (error instanceof ConflictException) {
        throw error;
      }
      throw new BadRequestException(
        `Failed to confirm sales order: ${error.message}`,
      );
    }
  }

  async updateStatus(id: string, newStatus: OrderStatus, userId?: string) {
    try {
      const order = await this.findOne(id);

      if (!this.validateStatusTransition(order.status!, newStatus)) {
        throw new ConflictException(
          `Cannot transition from ${order.status} to ${newStatus}`,
        );
      }

      // Special handling for completing orders
      if (newStatus === OrderStatus.COMPLETED) {
        if (order.payment_status !== PaymentStatus.PAID) {
          throw new ConflictException(
            'Order must be fully paid before completing',
          );
        }
      }

      const updatedOrder = await this.prisma.sales_orders.update({
        where: { id },
        data: {
          status: newStatus,
          processed_by: userId,
          ...(newStatus === OrderStatus.COMPLETED && {
            delivered_date: new Date(),
          }),
        },
        include: {
          customers: true,
          stores: true,
          user_profiles_sales_orders_created_byTouser_profiles: true,
          user_profiles_sales_orders_processed_byTouser_profiles: true,
          sales_order_items: {
            include: {
              products: true,
              product_variants: true,
            },
          },
          sales_order_payments: true,
        },
      });

      return updatedOrder;
    } catch (error) {
      if (error instanceof ConflictException) {
        throw error;
      }
      throw new BadRequestException(
        `Failed to update order status: ${error.message}`,
      );
    }
  }

  async getStatistics(query: {
    from_date?: string;
    to_date?: string;
    created_by?: string;
    channel?: string;
  }) {
    const where: Prisma.sales_ordersWhereInput = {
      status: { not: OrderStatus.CANCELLED },
    };

    if (query.from_date || query.to_date) {
      where.created_at = {};
      if (query.from_date) where.created_at.gte = new Date(query.from_date);
      if (query.to_date) where.created_at.lte = new Date(query.to_date);
    }

    if (query.created_by) where.created_by = query.created_by;
    if (query.channel) where.channel = query.channel;

    const [totalOrders, completedOrders, revenue, discounts] =
      await Promise.all([
        this.prisma.sales_orders.count({ where }),
        this.prisma.sales_orders.count({
          where: { ...where, status: OrderStatus.COMPLETED },
        }),
        this.prisma.sales_orders.aggregate({
          where: {
            ...where,
            status: { in: [OrderStatus.COMPLETED, OrderStatus.READY] },
          },
          _sum: { total_amount: true },
        }),
        this.prisma.sales_orders.aggregate({
          where: {
            ...where,
            status: { in: [OrderStatus.COMPLETED, OrderStatus.READY] },
          },
          _sum: { discount_amount: true },
        }),
      ]);

    return {
      totalOrders,
      completedOrders,
      totalRevenue: Number(revenue._sum.total_amount || 0),
      totalDiscounts: Number(discounts._sum.discount_amount || 0),
    };
  }

  async getReportByEmployee(query: { from_date?: string; to_date?: string }) {
    const where: Prisma.sales_ordersWhereInput = {
      status: { in: [OrderStatus.COMPLETED, OrderStatus.READY] },
    };

    if (query.from_date || query.to_date) {
      where.created_at = {};
      if (query.from_date) where.created_at.gte = new Date(query.from_date);
      if (query.to_date) where.created_at.lte = new Date(query.to_date);
    }

    const orders = await this.prisma.sales_orders.findMany({
      where,
      include: {
        user_profiles_sales_orders_created_byTouser_profiles: true,
      },
    });

    // Group by employee
    const byEmployee: Record<
      string,
      {
        employee_id: string;
        employee_name: string;
        order_count: number;
        total_revenue: number;
        total_discount: number;
      }
    > = {};

    for (const order of orders) {
      const employeeId = order.created_by || 'unknown';
      const employeeName =
        order.user_profiles_sales_orders_created_byTouser_profiles?.full_name ||
        'Unknown';

      if (!byEmployee[employeeId]) {
        byEmployee[employeeId] = {
          employee_id: employeeId,
          employee_name: employeeName,
          order_count: 0,
          total_revenue: 0,
          total_discount: 0,
        };
      }

      byEmployee[employeeId].order_count++;
      byEmployee[employeeId].total_revenue += Number(order.total_amount || 0);
      byEmployee[employeeId].total_discount += Number(
        order.discount_amount || 0,
      );
    }

    return Object.values(byEmployee).sort(
      (a, b) => b.total_revenue - a.total_revenue,
    );
  }

  async getReportByChannel(query: { from_date?: string; to_date?: string }) {
    const where: Prisma.sales_ordersWhereInput = {
      status: { in: [OrderStatus.COMPLETED, OrderStatus.READY] },
    };

    if (query.from_date || query.to_date) {
      where.created_at = {};
      if (query.from_date) where.created_at.gte = new Date(query.from_date);
      if (query.to_date) where.created_at.lte = new Date(query.to_date);
    }

    const orders = await this.prisma.sales_orders.findMany({
      where,
    });

    // Group by channel
    const byChannel: Record<
      string,
      {
        channel: string;
        order_count: number;
        total_revenue: number;
        total_discount: number;
      }
    > = {};

    for (const order of orders) {
      const channel = order.channel;

      if (!byChannel[channel]) {
        byChannel[channel] = {
          channel,
          order_count: 0,
          total_revenue: 0,
          total_discount: 0,
        };
      }

      byChannel[channel].order_count++;
      byChannel[channel].total_revenue += Number(order.total_amount || 0);
      byChannel[channel].total_discount += Number(order.discount_amount || 0);
    }

    return Object.values(byChannel).sort(
      (a, b) => b.total_revenue - a.total_revenue,
    );
  }
}
