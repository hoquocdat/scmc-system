import {
  Injectable,
  NotFoundException,
  BadRequestException,
  ConflictException,
} from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CreateSalesOrderDto, OrderStatus, PaymentStatus } from './dto/create-sales-order.dto';
import { UpdateSalesOrderDto } from './dto/update-sales-order.dto';
import { SalesOrderQueryDto } from './dto/sales-order-query.dto';
import { CreatePaymentDto } from './dto/create-payment.dto';
import { Prisma } from '@prisma/client';

@Injectable()
export class SalesService {
  constructor(private prisma: PrismaService) {}

  async create(createSalesOrderDto: CreateSalesOrderDto) {
    try {
      const { items, ...orderData } = createSalesOrderDto;

      // Calculate totals if not provided
      let subtotal = orderData.subtotal || 0;
      let discountAmount = orderData.discount_amount || 0;
      let taxAmount = orderData.tax_amount || 0;

      if (!orderData.subtotal) {
        subtotal = items.reduce((sum, item) => sum + item.unit_price * item.quantity, 0);
        discountAmount = items.reduce((sum, item) => sum + (item.discount_amount || 0) * item.quantity, 0);
        taxAmount = items.reduce((sum, item) => sum + (item.tax_amount || 0) * item.quantity, 0);
      }

      const totalAmount =
        orderData.total_amount || subtotal - discountAmount + taxAmount + (orderData.shipping_cost || 0);

      // Prepare order data (order_number will be auto-generated by database)
      const data: Prisma.sales_ordersCreateInput = {
        order_number: '', // Will be auto-generated by database trigger
        customer_name: orderData.customer_name,
        customer_phone: orderData.customer_phone,
        customer_email: orderData.customer_email,
        channel: orderData.channel,
        status: orderData.status || OrderStatus.PENDING,
        payment_status: orderData.payment_status || PaymentStatus.UNPAID,
        subtotal: new Prisma.Decimal(subtotal),
        discount_amount: new Prisma.Decimal(discountAmount),
        tax_amount: new Prisma.Decimal(taxAmount),
        shipping_cost: orderData.shipping_cost ? new Prisma.Decimal(orderData.shipping_cost) : undefined,
        total_amount: new Prisma.Decimal(totalAmount),
        shipping_address: orderData.shipping_address,
        shipping_city: orderData.shipping_city,
        notes: orderData.notes,
        stock_locations: orderData.location_id ? {
          connect: { id: orderData.location_id },
        } : undefined,
      };

      if (orderData.customer_id) {
        data.customers = { connect: { id: orderData.customer_id } };
      }

      if (orderData.created_by) {
        data.user_profiles_sales_orders_created_byTouser_profiles = { connect: { id: orderData.created_by } };
      }

      // Create order with items in a transaction
      const order = await this.prisma.$transaction(async (tx) => {
        // Create the order (order_number will be auto-generated by database function)
        const newOrder = await tx.sales_orders.create({
          data,
          include: {
            customers: true,
            stock_locations: true,
            user_profiles_sales_orders_created_byTouser_profiles: true,
          },
        });

        // Create order items
        const orderItems = await Promise.all(
          items.map((item) => {
            const totalPrice = (item.unit_price - (item.discount_amount || 0) + (item.tax_amount || 0)) * item.quantity;

            const itemData: Prisma.sales_order_itemsCreateInput = {
              product_name: '', // Will be filled from product
              quantity: item.quantity,
              unit_price: new Prisma.Decimal(item.unit_price),
              discount_amount: item.discount_amount ? new Prisma.Decimal(item.discount_amount) : undefined,
              tax_amount: item.tax_amount ? new Prisma.Decimal(item.tax_amount) : undefined,
              total_amount: new Prisma.Decimal(totalPrice),
              notes: item.notes,
              sales_orders: { connect: { id: newOrder.id } },
              products: { connect: { id: item.product_id } },
            };

            if (item.product_variant_id) {
              itemData.product_variants = { connect: { id: item.product_variant_id } };
            }

            return tx.sales_order_items.create({
              data: itemData,
              include: {
                products: true,
                product_variants: true,
              },
            });
          }),
        );

        // Create inventory transactions for each item (SALE type)
        if (orderData.location_id) {
          await Promise.all(
            items.map((item) => {
              const transactionData: Prisma.inventory_transactionsCreateInput = {
                transaction_type: 'SALE',
                quantity: -Math.abs(item.quantity),
                reference_id: newOrder.id,
                reference_type: 'sales_order',
                stock_locations: { connect: { id: orderData.location_id } },
                products: { connect: { id: item.product_id } },
              };

              if (item.product_variant_id) {
                transactionData.product_variants = { connect: { id: item.product_variant_id } };
              }

              if (orderData.created_by) {
                transactionData.user_profiles = { connect: { id: orderData.created_by } };
              }

              return tx.inventory_transactions.create({
                data: transactionData,
              });
            }),
          );
        }

        return { ...newOrder, sales_order_items: orderItems };
      });

      return order;
    } catch (error) {
      throw new BadRequestException(`Failed to create sales order: ${error.message}`);
    }
  }

  async findAll(query: SalesOrderQueryDto) {
    const { page = 1, limit = 20, search, sort_by = 'created_at', sort_order = 'desc', from_date, to_date, ...filters } = query;
    const skip = (page - 1) * limit;

    const where: Prisma.sales_ordersWhereInput = {};

    if (search) {
      where.OR = [
        { order_number: { contains: search, mode: 'insensitive' } },
        { customer_name: { contains: search, mode: 'insensitive' } },
        { customer_phone: { contains: search, mode: 'insensitive' } },
      ];
    }

    if (filters.customer_id) where.customer_id = filters.customer_id;
    if (filters.location_id) where.location_id = filters.location_id;
    if (filters.created_by) where.created_by = filters.created_by;
    if (filters.processed_by) where.processed_by = filters.processed_by;
    if (filters.status) where.status = filters.status;
    if (filters.payment_status) where.payment_status = filters.payment_status;
    if (filters.channel) where.channel = filters.channel;

    if (from_date || to_date) {
      where.created_at = {};
      if (from_date) where.created_at.gte = new Date(from_date);
      if (to_date) where.created_at.lte = new Date(to_date);
    }

    const [orders, total] = await Promise.all([
      this.prisma.sales_orders.findMany({
        where,
        skip,
        take: limit,
        orderBy: { [sort_by]: sort_order },
        include: {
          customers: true,
          stock_locations: true,
          user_profiles_sales_orders_created_byTouser_profiles: true,
          user_profiles_sales_orders_processed_byTouser_profiles: true,
          sales_order_items: {
            include: {
              products: true,
              product_variants: true,
            },
          },
          sales_order_payments: true,
        },
      }),
      this.prisma.sales_orders.count({ where }),
    ]);

    return {
      data: orders,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  async findOne(id: string) {
    const order = await this.prisma.sales_orders.findUnique({
      where: { id },
      include: {
        customers: true,
        stock_locations: true,
        user_profiles_sales_orders_created_byTouser_profiles: true,
        user_profiles_sales_orders_processed_byTouser_profiles: true,
        sales_order_items: {
          include: {
            products: true,
            product_variants: true,
          },
        },
        sales_order_payments: {
          include: {
            user_profiles: true,
          },
        },
      },
    });

    if (!order) {
      throw new NotFoundException(`Sales order with ID "${id}" not found`);
    }

    return order;
  }

  async update(id: string, updateSalesOrderDto: UpdateSalesOrderDto) {
    try {
      await this.findOne(id);

      const data: Prisma.sales_ordersUpdateInput = {
        ...updateSalesOrderDto,
        subtotal: updateSalesOrderDto.subtotal ? new Prisma.Decimal(updateSalesOrderDto.subtotal) : undefined,
        discount_amount: updateSalesOrderDto.discount_amount ? new Prisma.Decimal(updateSalesOrderDto.discount_amount) : undefined,
        tax_amount: updateSalesOrderDto.tax_amount ? new Prisma.Decimal(updateSalesOrderDto.tax_amount) : undefined,
        shipping_cost: updateSalesOrderDto.shipping_cost ? new Prisma.Decimal(updateSalesOrderDto.shipping_cost) : undefined,
        total_amount: updateSalesOrderDto.total_amount ? new Prisma.Decimal(updateSalesOrderDto.total_amount) : undefined,
      };

      if (updateSalesOrderDto.customer_id) {
        data.customers = { connect: { id: updateSalesOrderDto.customer_id } };
      }

      if (updateSalesOrderDto.location_id) {
        data.stock_locations = { connect: { id: updateSalesOrderDto.location_id } };
      }

      if (updateSalesOrderDto.created_by) {
        data.user_profiles_sales_orders_created_byTouser_profiles = { connect: { id: updateSalesOrderDto.created_by } };
      }

      const updatedOrder = await this.prisma.sales_orders.update({
        where: { id },
        data,
        include: {
          customers: true,
          stock_locations: true,
          user_profiles_sales_orders_created_byTouser_profiles: true,
          user_profiles_sales_orders_processed_byTouser_profiles: true,
          sales_order_items: {
            include: {
              products: true,
              product_variants: true,
            },
          },
          sales_order_payments: true,
        },
      });

      return updatedOrder;
    } catch (error) {
      throw new BadRequestException(`Failed to update sales order: ${error.message}`);
    }
  }

  async cancel(id: string) {
    try {
      const order = await this.findOne(id);

      if (order.status === OrderStatus.CANCELLED) {
        throw new ConflictException('Order is already cancelled');
      }

      if (order.status === OrderStatus.COMPLETED) {
        throw new ConflictException('Cannot cancel a completed order');
      }

      // Cancel the order and create RETURN inventory transactions
      const cancelledOrder = await this.prisma.$transaction(async (tx) => {
        // Update order status
        const updated = await tx.sales_orders.update({
          where: { id },
          data: {
            status: OrderStatus.CANCELLED,
          },
          include: {
            sales_order_items: {
              include: {
                products: true,
                product_variants: true,
              },
            },
          },
        });

        // Create RETURN transactions for inventory items
        if (order.location_id) {
          for (const item of updated.sales_order_items) {
            await tx.inventory_transactions.create({
              data: {
                transaction_type: 'RETURN',
                quantity: Math.abs(item.quantity),
                reference_id: order.id,
                reference_type: 'sales_order_cancellation',
                stock_locations: { connect: { id: order.location_id } },
                products: { connect: { id: item.product_id! } },
                product_variants: item.product_variant_id ? { connect: { id: item.product_variant_id } } : undefined,
              },
            });
          }
        }

        return updated;
      });

      return cancelledOrder;
    } catch (error) {
      throw new BadRequestException(`Failed to cancel sales order: ${error.message}`);
    }
  }

  async addPayment(createPaymentDto: CreatePaymentDto) {
    try {
      const order = await this.findOne(createPaymentDto.sales_order_id);

      // Calculate total paid after this payment
      const totalPaid = order.sales_order_payments.reduce(
        (sum, payment) => sum + Number(payment.amount),
        0,
      );

      const totalAmount = Number(order.total_amount);
      const newPaidAmount = totalPaid + createPaymentDto.amount;

      if (newPaidAmount > totalAmount) {
        throw new BadRequestException('Payment amount exceeds order total');
      }

      // Create payment
      const payment = await this.prisma.sales_order_payments.create({
        data: {
          sales_orders: { connect: { id: createPaymentDto.sales_order_id } },
          payment_method: createPaymentDto.payment_method,
          amount: new Prisma.Decimal(createPaymentDto.amount),
          transaction_id: createPaymentDto.transaction_id,
          authorization_code: createPaymentDto.authorization_code,
          amount_tendered: createPaymentDto.amount_tendered ? new Prisma.Decimal(createPaymentDto.amount_tendered) : undefined,
          change_given: createPaymentDto.change_given ? new Prisma.Decimal(createPaymentDto.change_given) : undefined,
          notes: createPaymentDto.notes,
          user_profiles: createPaymentDto.received_by ? { connect: { id: createPaymentDto.received_by } } : undefined,
        },
        include: {
          sales_orders: true,
          user_profiles: true,
        },
      });

      // Update order payment status
      let paymentStatus = PaymentStatus.PARTIAL;
      if (newPaidAmount >= totalAmount) {
        paymentStatus = PaymentStatus.PAID;
      } else if (newPaidAmount === 0) {
        paymentStatus = PaymentStatus.UNPAID;
      }

      await this.prisma.sales_orders.update({
        where: { id: createPaymentDto.sales_order_id },
        data: {
          payment_status: paymentStatus,
          payment_date: paymentStatus === PaymentStatus.PAID ? new Date() : null,
        },
      });

      return payment;
    } catch (error) {
      throw new BadRequestException(`Failed to add payment: ${error.message}`);
    }
  }
}
