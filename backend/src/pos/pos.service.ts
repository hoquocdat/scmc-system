import {
  Injectable,
  NotFoundException,
  BadRequestException,
  ConflictException,
} from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { CreatePosSessionDto } from './dto/create-pos-session.dto';
import { ClosePosSessionDto } from './dto/close-pos-session.dto';
import { PosSessionQueryDto, PosSessionStatus } from './dto/pos-session-query.dto';
import { CreatePosTransactionDto } from './dto/create-pos-transaction.dto';
import { Prisma } from '@prisma/client';

@Injectable()
export class PosService {
  constructor(private prisma: PrismaService) {}

  // Create a new POS session
  async createSession(createPosSessionDto: CreatePosSessionDto) {
    try {
      // Check if user already has an open session at this location
      const existingSession = await this.prisma.pos_sessions.findFirst({
        where: {
          user_id: createPosSessionDto.user_id,
          location_id: createPosSessionDto.location_id,
          status: PosSessionStatus.OPEN,
        },
      });

      if (existingSession) {
        throw new ConflictException(
          'User already has an open POS session at this location',
        );
      }

      const session = await this.prisma.pos_sessions.create({
        data: {
          session_number: '', // Will be auto-generated by database trigger
          location_id: createPosSessionDto.location_id,
          user_id: createPosSessionDto.user_id,
          opening_cash: new Prisma.Decimal(createPosSessionDto.opening_cash),
          status: PosSessionStatus.OPEN,
          notes: createPosSessionDto.notes,
        },
        include: {
          stock_locations: true,
          user_profiles: true,
        },
      });

      return session;
    } catch (error) {
      if (error instanceof ConflictException) {
        throw error;
      }
      throw new BadRequestException(
        `Failed to create POS session: ${error.message}`,
      );
    }
  }

  // Get all POS sessions with filtering
  async findAll(query: PosSessionQueryDto) {
    const {
      page = 1,
      limit = 20,
      sort_by = 'opened_at',
      sort_order = 'desc',
      from_date,
      to_date,
      ...filters
    } = query;
    const skip = (page - 1) * limit;

    const where: Prisma.pos_sessionsWhereInput = {};

    if (filters.location_id) where.location_id = filters.location_id;
    if (filters.user_id) where.user_id = filters.user_id;
    if (filters.status) where.status = filters.status;

    if (from_date || to_date) {
      where.opened_at = {};
      if (from_date) where.opened_at.gte = new Date(from_date);
      if (to_date) where.opened_at.lte = new Date(to_date);
    }

    const [sessions, total] = await Promise.all([
      this.prisma.pos_sessions.findMany({
        where,
        skip,
        take: limit,
        orderBy: { [sort_by]: sort_order },
        include: {
          stock_locations: true,
          user_profiles: true,
          pos_session_transactions: true,
        },
      }),
      this.prisma.pos_sessions.count({ where }),
    ]);

    return {
      data: sessions,
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  // Get a single POS session
  async findOne(id: string) {
    const session = await this.prisma.pos_sessions.findUnique({
      where: { id },
      include: {
        stock_locations: true,
        user_profiles: true,
        pos_session_transactions: {
          orderBy: {
            created_at: 'desc',
          },
        },
      },
    });

    if (!session) {
      throw new NotFoundException(`POS session with ID "${id}" not found`);
    }

    return session;
  }

  // Get current open session for a user at a location
  async getCurrentSession(userId: string, locationId: string) {
    const session = await this.prisma.pos_sessions.findFirst({
      where: {
        user_id: userId,
        location_id: locationId,
        status: PosSessionStatus.OPEN,
      },
      include: {
        stock_locations: true,
        user_profiles: true,
        pos_session_transactions: {
          orderBy: {
            created_at: 'desc',
          },
        },
      },
    });

    if (!session) {
      throw new NotFoundException(
        'No open POS session found for this user at this location',
      );
    }

    return session;
  }

  // Close a POS session
  async closeSession(id: string, closePosSessionDto: ClosePosSessionDto) {
    try {
      const session = await this.findOne(id);

      if (session.status === PosSessionStatus.CLOSED) {
        throw new ConflictException('POS session is already closed');
      }

      // Calculate expected cash (opening + all transactions)
      const transactions = session.pos_session_transactions || [];
      const transactionTotal = transactions.reduce(
        (sum, txn) => sum + Number(txn.amount),
        0,
      );
      const expectedCash = Number(session.opening_cash) + transactionTotal;
      const cashDifference =
        closePosSessionDto.closing_cash - expectedCash;

      const closedSession = await this.prisma.pos_sessions.update({
        where: { id },
        data: {
          status: PosSessionStatus.CLOSED,
          closing_cash: new Prisma.Decimal(closePosSessionDto.closing_cash),
          expected_cash: new Prisma.Decimal(expectedCash),
          cash_difference: new Prisma.Decimal(cashDifference),
          closed_at: new Date(),
          notes: closePosSessionDto.notes || session.notes,
        },
        include: {
          stock_locations: true,
          user_profiles: true,
          pos_session_transactions: true,
        },
      });

      return closedSession;
    } catch (error) {
      if (
        error instanceof NotFoundException ||
        error instanceof ConflictException
      ) {
        throw error;
      }
      throw new BadRequestException(
        `Failed to close POS session: ${error.message}`,
      );
    }
  }

  // Add a transaction to a POS session
  async addTransaction(createPosTransactionDto: CreatePosTransactionDto) {
    try {
      const session = await this.findOne(
        createPosTransactionDto.pos_session_id,
      );

      if (session.status === PosSessionStatus.CLOSED) {
        throw new ConflictException(
          'Cannot add transaction to a closed POS session',
        );
      }

      const transaction = await this.prisma.pos_session_transactions.create({
        data: {
          pos_session_id: createPosTransactionDto.pos_session_id,
          transaction_type: createPosTransactionDto.transaction_type,
          amount: new Prisma.Decimal(createPosTransactionDto.amount),
          reason: createPosTransactionDto.reason,
          notes: createPosTransactionDto.notes,
        },
      });

      return transaction;
    } catch (error) {
      if (
        error instanceof NotFoundException ||
        error instanceof ConflictException
      ) {
        throw error;
      }
      throw new BadRequestException(
        `Failed to add transaction: ${error.message}`,
      );
    }
  }

  // Get session statistics
  async getSessionStats(id: string) {
    const session = await this.findOne(id);

    const transactions = session.pos_session_transactions || [];
    const cashIn = transactions
      .filter((txn) => Number(txn.amount) > 0)
      .reduce((sum, txn) => sum + Number(txn.amount), 0);
    const cashOut = transactions
      .filter((txn) => Number(txn.amount) < 0)
      .reduce((sum, txn) => sum + Math.abs(Number(txn.amount)), 0);
    const netTransactions = cashIn - cashOut;
    const expectedCash = Number(session.opening_cash) + netTransactions;

    return {
      session_id: session.id,
      session_number: session.session_number,
      status: session.status,
      opening_cash: Number(session.opening_cash),
      closing_cash: session.closing_cash ? Number(session.closing_cash) : null,
      expected_cash: expectedCash,
      cash_difference: session.cash_difference
        ? Number(session.cash_difference)
        : null,
      total_cash_in: cashIn,
      total_cash_out: cashOut,
      net_transactions: netTransactions,
      transaction_count: transactions.length,
    };
  }
}
